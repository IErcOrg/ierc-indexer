// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/IErcOrg/IERC_Indexer/internal/conf"
	"github.com/IErcOrg/IERC_Indexer/internal/domain/protocol/parser"
	"github.com/IErcOrg/IERC_Indexer/internal/domain/service"
	"github.com/IErcOrg/IERC_Indexer/internal/facade"
	"github.com/IErcOrg/IERC_Indexer/internal/facade/handler"
	"github.com/IErcOrg/IERC_Indexer/internal/infrastructure/repository"
	"github.com/IErcOrg/IERC_Indexer/internal/infrastructure/repository/mysql"
	"github.com/IErcOrg/IERC_Indexer/internal/infrastructure/repository/network/ethereum"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
)

import (
	_ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(string2 string, logger log.Logger) (*kratos.App, func(), error) {
	config, cleanup, err := conf.NewConfigFromPath(string2, logger)
	if err != nil {
		return nil, nil, err
	}
	parserParser := parser.NewParser()
	blockFetcher, err := ethereum.NewEthereumFetcher(config, parserParser, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	db, cleanup2, err := repository.NewDB(config, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	blockRepository := mysqlimpl.NewBlockRepo(db, parserParser)
	eventRepository := mysqlimpl.NewEventRepository(db)
	bigCache, cleanup3, err := repository.NewCache()
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	data := repository.NewData(db, bigCache)
	transactionRepository := repository.NewTransactionRepository(data)
	tickRepository := repository.NewTickRepository(db, bigCache)
	balanceRepository := repository.NewBalanceRepository(db, bigCache)
	stakingRepository, err := repository.NewStakingRepository(db)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	blockService, err := service.NewBlockService(config, logger, blockRepository, eventRepository, transactionRepository, tickRepository, balanceRepository, stakingRepository)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	indexDomainService := service.NewIndexApplication(config, logger, blockFetcher, blockRepository, blockService)
	indexHandler := handler.NewIndexHandler(indexDomainService, eventRepository, blockFetcher, blockRepository, logger)
	server := facade.NewGRPCServer(config, indexHandler, logger)
	httpServer := facade.NewHTTPServer(config, indexHandler, logger)
	app := newApp(logger, indexDomainService, indexHandler, server, httpServer)
	return app, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}
